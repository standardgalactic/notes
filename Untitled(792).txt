

3. Core principles of recurrent linearized Transformers in 1993The slow net and the fast net of the 1991 system[FWP0-1] in Sec. 2 were feedforward NNs (FNNs), like most current Transformers.[TR1-6] In 1993, however, to combine the best of both recurrent NNs (RNNs) and fast weights, I collapsed all of this into a single RNN that could rapidly reprogram all of its own fast weights through additive outer product-based weight changes.[FWP2]

One motivation reflected by the title of the paper[FWP2] was to get many more temporal variables under massively parallel end-to-end differentiable control than what's possible in standard RNNs of the same size: O(H2) instead of O(H), where H is the number of hidden units. This motivation and a variant of the method was republished over two decades later.[FWP4a][R4][MIR](Sec. 8)[T22](Sec. XVII, item H3)

See also our more recent work on FWPs since 2017,[FWP3-3a][FWPMETA7][FWP6] and compare a recent study.[RA21]

4. Attention terminology of 1993￼Today, everybody is talking about attention when it comes to describing the principles of Transformers.[TR1-2] The additive outer products[FWP0-1] of the Fast Weight Programmers described in Sec. 2 and Sec. 3 are often viewed as attention layers. Similarly, the attention weights or self-attention weights (see also[FWP4b-d]) in Transformers can be viewed as context-dependent weight vectors or NN-programmed fast weights (Sec. 5).[FWP0-1], Sec. 9 & Sec. 8 of [MIR], Sec. XVII of [T22]

This kind of attention-oriented terminology was introduced in my 1993 paper[FWP2] which explicitly mentioned the learning of internal spotlights of attention in its additive outer product-based (or second order tensor product-based) Fast Weight Programmers.[FWP2][ATT]

5. Dual additive paths towards deep learning: LSTM v fast weight programsApart from possible normalization/squashing,[FWP0] the 1991 Fast Weight Programmer's weight changes are additive (Sec. 1 & 2). Additive FWPs do not suffer during sequence learning from the famous vanishing gradient problem aka deep learning problem. In fact, they embody a solution to this problem which was first analyzed by my brilliant student Sepp Hochreiter a few months later in his 1991 diploma thesis.[VAN1]

￼It turns out that the problem can be solved in two closely related ways, both of them based on additive control of temporal storage, and both of them dating back to 1991, our miraculous year of deep learning.[MIR]

Basic Long Short-Term Memory[LSTM1] solves the problem by adding at every time step new real values to old internal neural activations through recurrent connections whose weights are always 1.0. That is, the core of LSTM is operating in a linear additive activation space (ignoring LSTM's multiplicative gates).[LSTM1][VAN1][MIR](Sec. 4 & Sec. 8)

Additive FWPs[FWP0-2] (Sec. 1 & 2), however, solve the problem through a dual approach, namely, by adding real values to fast weights (rather than neuron activations). That is, they are operating in an additive fast weight space. Since the fundamental operation of NNs is to multiply weights by activations, both approaches are symmetric. By favoring additive operations yielding non-vanishing first derivatives and error flow,[VAN1] both are in principle immune to the vanishing gradient problem, for the same reason.

Since 2017, Transformers[TR1-6] also follow the additive approach.[FWP0-2] Their context-dependent attention weights used for weighted averages of value vectors are like NN-programmed fast weights that change for each new input (compare Sec. 2 and Sec. 4 on attention terminology since 1993).

￼LSTM's traditional additive activation-based approach[LSTM1-13] is mirrored in the LSTM-inspired Highway Network (May 2015),[HW1][HW1a][HW3] the first working really deep feedforward neural network with hundreds of layers. It is essentially a feedforward version of LSTM[LSTM1] with forget gates.[LSTM2] If we open its gates (and keep them open), we obtain a special case called Residual Net or ResNet[HW2] (Dec 2015).

In sum, to solve the deep learning problem through additive control of some NN's internal storage, we may use either the family of additive Fast Weight Programmers / (linear) Transformers, or the dual family of LSTM / Highway Nets / ResNets. The former are easily parallelizable.

Remarkably, both of these dual approaches of 1991 have become successful. By the mid 2010s,[DEC] all the major IT companies overwhelmingly used LSTMs for speech recognition, natural language processing (NLP), machine translation, and many other AI applications. For example, LSTMs were used for translating texts many billions of times per day on billions of smartphones.[DL4] In recent years, however, Transformers have excelled at the traditional LSTM domain of NLP[TR1-2]—although there are still many language tasks that LSTM can rapidly learn to solve quickly[LSTM13] while plain Transformers can't yet.[TR4]

An orthogonal approach to solving the deep learning problem is based on unsupervised pre-training of deep NNs.[UN0-UN2][MIR](Sec. 1) Remarkably, this approach also dates back to 1991[UN] (which happens to be the only palindromic year of the 20th century).

6. Most recent work on Fast Weight Programmers / Transformers (2021-)Note: The following Sections were edited in 2022 to reflect our most recent work.

Recent work of February 2021[FWP6] with my PhD student Imanol Schlag and my postdoc Kazuki Irie not only emphasizes the formal equivalence of linear Transformer-like self-attention mechanisms[TR5-6] and Fast Weight Programmers[FWP0-2] (Sec. 2).[FWP4a][R4][MIR](Sec. 8)[T22](Sec. XVII, item H3) We also infer a memory capacity limitation of recent linearized softmax attention variants.[TR5-6] With finite memory, a desirable behavior of FWPs is to manipulate the contents of memory and dynamically interact with it. Building on previous work[FWPMETA7] on FWPs (Sec. 1, 2, 3, 8), we replace the 1991 elementary programming instruction based on additive outer products[FWP0-2] by a delta rule-like[WID] programming instruction, such that the FWP can more easily learn to correct the current mapping from keys to values. The FWP also learns to compute dynamically changing learning rates. We also introduce a new kernel function to linearize attention, balancing simplicity and effectiveness. To demonstrate the benefits of our methods, we conduct experiments on synthetic retrieval problems as well as standard machine translation and language modeling tasks.[FWP6] Our code is public.

Our work of June 2021[FWP7] (also with Robert Csordas) points out that the original FWP formulation of 1991[FWP0-1] is more general than the one of linear Transformers: a slow NN continually reprograms the weights of a fast NN with arbitrary NN architectures. In existing linear Transformers, both NNs are feedforward and consist of a single layer. Here we explore new variations by adding recurrence to the slow and fast NNs. We evaluate our novel recurrent FWPs on two synthetic algorithmic tasks (code execution and sequential ListOps), Wikitext-103 language models, and on the Atari 2600 2D game environment. Our models exhibit properties of both Transformers and RNNs. In a reinforcement learning setting, we report large improvements over LSTM in several Atari games. Our code is public.

7. Fast weights for reinforcement learning / neuroevolution (2005-)

￼

Deep reinforcement learning (RL) without a teacher can profit from fast weights even when the environment's dynamics are not differentiable, as shown in 2005 with my former postdoc Faustino Gomez[FWP5] (now CEO of NNAISENSE) when affordable computers were about 1000 times faster than in the early 1990s. For example, a robot with three wheels controlled by a Fast Weight Programmer learned to balance a pole topped by another pole. Our 2005 paper on deep RL[DL6,6a] was actually the first machine learning publication with the word combination "learn deep" in the title.

In the past 3 decades we have published quite a few additional ways of learning to quickly generate numerous weights of large NNs through very compact codes.[KO0-2][CO1-4] Here we exploited that the Kolmogorov complexity or algorithmic information content of successful huge NNs may actually be rather small. For example, in July 2013, the compact codes of Compressed Network Search[CO2] yielded the first deep learning model to successfully learn control policies directly from high-dimensional sensory input (video) using RL (in this case RL through neuroevolution), without any unsupervised pre-training.

Recent work of 2022[GGP] with my students Francesco Faccio, Vincent Herrmann, Aditya Ramesh, and Louis Kirsch showed how Fast Weight Programmers can be used for RL through goal-conditioned generators of deep NNs that represent policies.

8. Metalearning with Fast Weight Programmers

￼My first work on metalearning machines that learn to learn was published in 1987.[META][R3] Five years later, I showed how Fast Weight Programmers can also be used for metalearning in a very general way. In references[FWPMETA1-5] since 1992, the slow NN and the fast NN (Sec. 1) are recurrent and identical. The RNN can see its own errors or reward signals called eval(t+1) in the image.[FWPMETA5] The initial weight of each connection is trained by gradient descent, but during a training episode, each connection can be addressed and read and modified by the RNN itself through O(log n) special output units, where n is the number of connections—see time-dependent vectors mod(t), anal(t), Δ(t), val(t+1) in the image. That is, each connection's weight may rapidly change, and the network becomes self-referential in the sense that it can in principle run arbitrary computable weight change algorithms or learning algorithms (for all of its weights) on itself.

The 1993 FWP of Sec. 3[FWP2] also was an RNN that could quickly manipulate all of its own weights. However, unlike the self-referential RNN above,[FWPMETA1-5] it used outer products between key patterns and value patterns (Sec. 2) to manipulate many fast weights in parallel.

In 2001, Sepp et al. used gradient descent in LSTM networks[LSTM1] instead of traditional RNNs to metalearn fast online learning algorithms for nontrivial classes of functions, such as all quadratic functions of two variables[HO1] (more on LSTM and fast weights in Sec. 5). In 2020, Imanol et al. augmented an LSTM with an associative fast weight memory.[FWPMETA7] Through differentiable operations at every step of a given input sequence, the LSTM updates and maintains compositional associations of former observations stored in the rapidly changing fast weights. The model is trained end-to-end by gradient descent and yields excellent performance on compositional language reasoning problems, small-scale word-level language modelling, and meta-RL for partially observable environments.[FWPMETA7]

Our recent MetaGenRL (2020)[METARL10] meta-learns novel RL algorithms applicable to environments that significantly differ from those used for training. MetaGenRL searches the space of low-complexity loss functions that describe such learning algorithms. See the blog post of my PhD student Louis Kirsch. This principle of searching for simple learning algorithms is also applicable to fast weight architectures. Using weight sharing and sparsity, our recent Variable Shared Meta Learning (VS-ML) implicitly creates outer-product-like fast weights encoded in the activations of LSTMs.[FWPMETA6] This allows for encoding the learning algorithm by few parameters although it has many time-varying variables[FWP2] (Sec. 3). Some of these activations can be interpreted as NN weights updated by the LSTM dynamics. LSTMs with shared sparse entries in their weight matrix discover learning algorithms that generalize to new datasets. The meta-learned learning algorithms do not require explicit gradient calculation. VS-ML can also learn to implement the backpropagation learning algorithm[BP1-4] purely in the end-to-end differentiable forward dynamics of RNNs.[FWPMETA6]

In 2022, we also published at ICML a modern self-referential weight matrix (SWRM)[FWPMETA8] based on the 1992 SWRM.[FWPMETA1-5] In principle, it can meta-learn to learn, and meta-meta-learn to meta-learn to learn, and so on, in the sense of recursive self-improvement (compare this tweet). We evaluated our SRWM on supervised few-shot learning tasks and on multi-task reinforcement learning with procedurally generated game environments. The experiments demonstrated both practical applicability and competitive performance of the SRWM.

